> **📅 업로드 날짜**  
> 2025-07-30  
>
> **🗂 분류**  
> Database  
>
> **🔗 노션 링크**  
> [노션에서 보기](https://important-marquess-d42.notion.site/INDEX-23fa654e658a8016a49df048c92cb2ba?pvs=74)

# 인덱스(INDEX)

> 데이터 베이스의 테이블 안에서 데이터를 빠르게 찾을 수 있는 하나의 장치
> 

## 자료구조

- 인덱스는 B+-트리(Balanced Tree) 또는 해시(Hash) 등의 데이터 구조를 사용하여 구현.


### **B-Tree**

> 인덱스는 보통 **B-tree**라는 자료구조로 이루어져있으며 트리는 루트 노드, 리프 노드, 브랜치 노드로 나뉜다. 트리 탐색은 루트 노드부터 탐색하여 브랜치 노드를 거쳐 리프노드까지 내려오면서 탐색한다.
> 
- 인덱스가 있으면, B-Tree 인덱스를 통해 원하는 위치 탐색 → 해당 레코드 바로 접근
- 인덱스가 없으면, 테이블의 모든 데이터를 순차 검색 → 느림 (Full Table Scan)
  
<img width="1199" height="426" alt="image" src="https://github.com/user-attachments/assets/c1e1d832-3ed7-4c58-a2f4-9be776e382f6" />
<img width="1196" height="488" alt="image (1)" src="https://github.com/user-attachments/assets/7df6d302-dcdc-4ebd-b6d6-4efbc805b102" />



→ 효율적인 이유는 효율적으로 모든 요소에 접근할 수 있는 **균형잡힌 트리 구조**와 트리 깊이의 **대수 확장성** 때문이다.

**✅ 대수확장성**
    
> 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미하는데, 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.
> | 트리 깊이 | 인덱스 항목의 수 |
> | --- | --- |
> | 3 | 64 |
> | 4 | 256 |
> | 5 | 1,024 |
> | 6 | 4,096 |
> | 7 | 16,384 |
> | 8 | 65,536 |
> | 9 | 262,144 |
> | 10 | 1,048,576 |
> - 트리 깊이 10으로 100만 개의 레코드를 검색할 수 있다는 의미로 실제 인덱스는 이것보다 훨씬 더 효율적이다


### **해시**
- 특정 키를 매우 빠르게 검색할 수 있다
- 키의 순서를 보장하지 않는다
- 정확한 값을 입력해야지만 검색이 가능

## 인덱스 만드는 방법

- 인덱스를 만드는 법은 데이터 베이스(DB)마다 다르다.

### **MySQL**

MySQL의 경우 **클러스터형 인덱스**와 **세컨더리형 인덱스**가 있다.

- **클러스터형 인덱스**
    - 테이블당 하나를 설정할 수 있다.
    - **"primary key"** 옵션을 사용하여 기본키로 만들거나 기본키로 만들지 않고 **"unique not null"** 옵션을 붙이면 만들 수 있다.
- **세컨더리 인덱스**
    - create index... 명령어를 기반으로 만들 수 있다.
    - 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 사용하는 인덱스이다.

```sql
-- users 테이블
CREATE TABLE users (
  id INT PRIMARY KEY,         -- 👉 클러스터형 인덱스
  email VARCHAR(100),
  nickname VARCHAR(100),
  created_at DATETIME
);

-- 세컨더리 인덱스 (보조 인덱스)
CREATE INDEX idx_email ON users(email);           -- 이메일 자주 조회할 경우
CREATE INDEX idx_name_date ON users(nickname, created_at);  -- 복합 조건 조회

```

🔸 클러스터형 인덱스: 테이블의 "실제 데이터"를 정렬된 인덱스 구조에 저장. →**빠름**,**하나만 가능**

🔸 세컨더리 인덱스: 보조 인덱스. 여러 개 생성 가능. →**다양한 조건 검색에 유리**

- 하나의 인덱스만 생성한다면 클러스터형 인덱스를 생성하는 것이 세컨더리 인덱스를 생성하는 것 보다 성능이 좋다.
- 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스, 다양한 필드를 기반으로 쿼리를 보낼 때는 세컨더리 인덱스를 사용하는 것이 좋다.

### MongoDB

도큐먼트를 만들면 자동으로 ObjectID가 형성되며 해당 키가 기본키로 설정된다. 그리고 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리 키를 같이 쓰는 복합 인덱스를 설정할 수 있다.**(NoSQL)**

**✅ 도큐먼트(Document)**
>    - MongoDB는 **테이블**이 아니라 **컬렉션(Collection)** 을 사용하고, 그 안에 저장되는 개별 데이터 단위
>    - **JSON과 유사한 구조(BSON)** 로 구성    
>```sql
>// users라는 컬렉션이 없으면 자동으로 생성
>    db.users.insertOne({
>      name: "하시윤",
>      email: "shyun@example.com",
>      age: 27
>    });
>``` 
>```json
>{
>    "_id": ObjectId("66b1234abcde5678f90a12cd"),
>    "name": "하시윤",
>    "email": "siyun@example.com",
>    "age": 25
>}
```
