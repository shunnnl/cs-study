> **📅 업로드 날짜**  
> 2025-07-27  
>
> **🗂 분류**  
> Database  
>
> **🔗 노션 링크**  
> [노션에서 보기](https://important-marquess-d42.notion.site/Redis-23ca654e658a804fbf04ffd35972f9f2?source=copy_link)

# 레디스(Redis)

- 캐시를 구현 하는 방법 중 한가지인 Redis
- 그외에도 임시 작업 큐, 실시간 패팅, 메시지 브로커 등 다양한 용도로 활용

## **인메모리 ( In-Memory )**

- 컴퓨터의 RAM에 데이터를 올려서 사용하는 방법
- 메모리 내부에서 처리가 되므로 데이터를 저장/조회할 때 하드디스크를 오고가는 과정을 거치지 않아 **속도가 빠름**⠀
- **하지만,** 서버의 메모리 용량을 초과하는 데이터를 처리할 경우, **데이터가 유실**될 수 있음

  ※ 휘발성 → 서버 꺼지면 가지고 있던 데이터가 사라짐 

## **Key, Value 구조**

- key-value 구조에서 value에 다양한 자료 구조가 제공으로 개발의 편의성을 증가시킴
- 하지만 관계형 쿼리나 복잡한 탐색을 할 수 없음.
<img width="594" height="375" alt="image (10)" src="https://github.com/user-attachments/assets/04f45905-3fcc-4597-8cd0-4859881f8442" />



(다양한 자료형 지원)

### **정렬이 필요하면 Sorted Set !**

- Sorted Set은 Redis가 지원하는 Data Type으로 하나의 key에 여러 Score와 Value로 구성된 자료구조입니다. value는 중복되지 않으며 score 기준으로 정렬되기 때문에 랭킹과 같은 정렬이 필요할 때 매우 유용한 Redis의 Data Type입니다.
- 셔터(올리브영 커뮤니티) 에서는 유저의 최근 행동 데이터를 근거로 추천 피드를 구성한다. Sorted set은 유저가 동작한 시간을 timestamp로 변환해 score에 저장하는 방식으로 활용됩니다. 유저의 행동 데이터를 시간순으로 정렬할 수 있기 때문에 유저의 최근 행동을 기반한 추천 게시물을 피드로 노출할 수 있습니다.

※ Sorted Set 가중치를 기준으로 오름차순으로 정렬되는 특징

<img width="800" height="834" alt="image (11)" src="https://github.com/user-attachments/assets/8283102d-466d-460c-92ad-189f52a1973f" />



출처 : https://oliveyoung.tech/2025-07-23/redis-tips-for-developer/

## **메모리 관리와 성능 최적화**

- Redis는 데이터를 메모리에서 처리하기 때문에 **빠른 성능**을 제공하지만, **메모리 사용량이 많아질 수 있다는 단점** 존재
- 특히 대용량 데이터를 다룰 때는 메모리 비용이 크게 증가할 수 있으므로, 데이터를 효율적으로 관리하고 메모리 사용을 최적화하는 전략이 필요한데.

### **메모리 최적화를 위한 방법**

- **TTL(Time To Live) →** 자동으로 데이터가 만료되도록 설정하여 메모리 사용을 줄일 수 있음
- **LRU(Least Recently Used)** 알고리즘을 적용하여 메모리를 효율적으로 관리
    
    ※ LRU 란 캐시 메모리 관리 기법으로, 가장 오랫동안 사용되지 않은 데이터를 우선적으로 제거하는 방식
    

### **데이터 손실을 방지하는 영속성 옵션**

- **RDB**(Snapshotting) 은 일정 주기마다 메모리 데이터를 디스크에 저장해 데이터를 백업
- **AOF** 는 데이터 변경이 일어나는 명령이 실행될때마다  log 파일에 기록하여 재시작 시 이를 기반으로 데이터를 복구할 수 있게 해줌

 

## 주의할 점

- 싱글 스레드
- 한번에 하나의 명령만을 처리 하여 Race Condition이 거의 발생하지 않음
- 하지만 하나의 명령만 수행이 가능하므로 처리 시간이 긴 요청의 경우 장애 발생 가능성 있음
    
    ※ Race Condition → 두개 이상의 프로세스가 동시적으로 하나의 리소스에 접근하려 경쟁하는걸 말함
    
- **메모리 단편화**
    
    메모리를 할당 받고 해제 하는 과정에서 아래 그림과 같이 부분부분 빈 공간이 생기게 되는데, 4번같이 새로운 메모리를 할당할때 알맞는 공간(4칸)이 없기 때문에 마지막부분(우측) 부분에 위치해야 되고, 그러면 빈 공간 메모리가 남아 낭비가 발생하게 된다.
    
    그리고 이 현상이 계속되면 실제 physical(RAM) 메모리가 커져 프로세스가 죽는 현상이 발생 할 수도 있다.
    
    그래서 실제 물리 메모리 사용량 모니터링이 필요 !
    <img width="824" height="412" alt="image (12)" src="https://github.com/user-attachments/assets/53a58825-4e65-433c-ad8d-4679309adade" />


