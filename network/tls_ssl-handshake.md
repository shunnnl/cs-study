> **📅 업로드 날짜**  
> 2025-09-02
> 
> **🗂 분류**  
> network
>
> **🔗 노션 링크**  
> [노션에서 보기](https://important-marquess-d42.notion.site/TLS-SSL-handshake-25ea654e658a80f8adb1e9b848a8b97b?source=copy_link)
>

# TLS/SSL handshake

- **SSL**의 용도는 웹을 통한 통신을 안전하게 유지하는 것.
- **TLS**는 **SSL**의 직접적인 후속이며 이제 모든 버전의 **SSL**이 더 이상 사용되지 않는다.
- 하지만 **TLS** 연결을 설명하는 데 **SSL**이라는 용어가 많이 사용됩니다. 대부분의 경우 **SSL** 및 **SSL/TLS**라는 용어 모두 **TLS** 프로토콜과 **TLS** 인증서를 나타낸다.
- HTTPS , TCP, UDP와 같은 일반적인 인터넷 통신에 **안전한 계층(layer)**을 추가하는 방식입니다.
- SSL 인증서 과정에는 대칭키 방식과 공개키 방식 두 개 모두 사용되었다. 모든 웹 콘텐츠의 전달을 공개키 방식으로 한다면 웹 서버와 브라우저에 많은 부담이 되기 때문에 SSL Handshake 단계까지는 **공개키 방식**, 그 이후의 HTTPS 통신은 **대칭키 방식**을 사용한다.

## 대칭키 / 비대킹키란?

- 대칭키 암호화 = 하나의 키 사용
- 비대칭키 암호화 = 공개키, 개인키 두개 사용

### 대칭키

- 하나의 키 로 평문을 암호화하고 다시 암호문을 평문으로 복호화할 때 사용하는 방식이다.
- 대문을 잠그는 자물쇠를 떠올려보면, 자물쇠를 잠근 열쇠만이 그 좌물쇠를 다시 열 수 있다. 즉 하나의 열쇠를 사용하는데, 만약 잃어버렸다? 보안취약 ㅠ

### 비대칭키 (공개키 암호화)

- 비대칭키 암호화는 (공개키)- (개인키) 두개를 가진다.
- A와 B가 있다고 가정했을때,
    - A는 (A공개키), (A개인키) 가 있을 것이고, A공개키로 암호화 한것은 A비밀키만 복호화가 가능
    - B는 (B공개키), (B개인키) 가 있을 것이다, B공개키로 암호화 한것은 B비밀키만 복호화가 가능
    - ex) A가 B에게 데이터를 보내고 싶다라는 예제를 들어보자
        - A는 (B공개키) 로 데이터를 암호화해서 보낸다
        - 그럼 B는 이걸 (B개인키)로 복호화 해서 데이터를 읽어들인다.

## 4. TLS 핸드셰이크

- HTTP/1.1·HTTP/2: `TCP 3-way handshake` → `**TLS 핸드셰이크**` → 그다음에야 HTTP 요청 전송
- `TCP 3-way handshake`  는 연결 성립하고 데이터 전송을 가능하게 하고
- 그위에 **`TLS** handshake`  를 진행해서 대칭키 기반 암호화된 데이터 전송한다.
- 즉, TLS는 HTTP 자체를 바꾸는 게 아니라, HTTP 위에 보안 계층을 얹어서 **HTTP Secure** ⇒ **HTTPS** 만듬


<img width="585" height="570" alt="image (26)" src="https://github.com/user-attachments/assets/7bb03c88-6b7c-41d8-a499-cef7c4b048d8" />

1. **ClientHello** 
    
    아래 제안 목록을 담아서 서버로 보냄
    
    - **SNI** : (접속하려는 호스트명 (www.example.com))
    - **ALPN (**어떤 HTTP 계층 프로토콜 쓸지 http/1.1 )
    - **Cipher Suites** (브라우저가 지원하는 암호화 방식 모음)
    - **Random** (난수)
    - **key_share** (클라이언트의 공개키)
    
2. **ServerHello**
 ClientHello 의 제안을 서버가 선택해서 응답합니다.
    - **Cipher Suite** (클라이언트가 보낸 후보 중 하나를 고름)
    - **Random** (난수)
    - **key_share** (서버의 공개키)
    - **ALPN** (프로토콜 선택)
    - 서버 인증서(SSL인증서) 전송
        - 서버 공개키 + 도메인 + CA(인증기관) 서명 포함
        - 클라이언트는 CA 공개키로 서명을 검증 → 서버 진위 확인
    
3. **Finished ↔ Finished**
    
    같은 키를 갖고 있고, 대화 내용이 변조되지 않았음을 서로 증명하는 마지막 단계
    
    - 서로 주고 받은 메세지를 사용해서  검증값(`verify_data`)을 만들고 서로 전송
    - 같은 검증값이 만들어지겠지
    - 그리고 서로 가지고 있는거랑 받은거랑 비교
        
        → 대화 내용이 변조되지 않았음을 확인
        
    
4. 대칭키를 만드는 과정
    - ECDH(타원곡선 디피-헬만) 같은 수학적 구조 때문에 같은 공유 비밀을 만들 수 있음
    - 클라이언트(C): privC * pubS
    - 서버(S): privS * pubC
        - 공유비밀에 클라이언트 난수+ 서버 난수 넣어 최종적인 **대칭키(Session Key)**를 만들어낸다.
        - 대칭키가 만들어진 순간부터 , TLS는 그 키로 모든 HTTP 요청과 응답을 암호화/복호화하면서 안전하게 통신을 이어간다.
