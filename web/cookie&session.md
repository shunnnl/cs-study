> **📅 업로드 날짜**  
> 2025-08-15
> 
> **🗂 분류**  
> web  
>
> **🔗 노션 링크**  
> [노션에서 보기](https://important-marquess-d42.notion.site/Cookie-Session-24da654e658a80409f00c48566c35897?source=copy_link)
>
> 
# 쿠키(Cookie) & 세션(Session)

## 쿠키(Cookie)

- **클라이언트에** 저장되는 데이터 조각
- 서버가 `Set-Cookie` 헤더로 전송하면 → 브라우저가 이를 저장 → 같은 도메인 요청시 `Cookie`도 자동으로 같이 전송
- 요청을 할때 자동으로 쿠키도 같이 전송

## 세션(Session)

- **서버 측**에서 클라이언트 상태를 저장하는 방식

## 세션 방식(회원관리)
<img width="800" height="621" alt="image" src="https://github.com/user-attachments/assets/9c785a6f-6303-4771-a555-694500b2b776" />




### 로그인 요청

- 아이디 + 비번 입력 후 로그인
- 쿠키도 세션도 없음

### 서버에서 인증처리

- 처음 DB 비교 후 로그인 성공
- 로그인한 사용자를 식별, 추적하기 위해 “세션” 생성
- 세션 저장소에 아래와 같이 저장


- ex) 세션 ID: abc123
데이터: { userId: 1, 이름: "홍길동", 권한: "USER" }



### 쿠키로 세션 ID 전달

- 서버가 생성한 세션ID를 브라우저에 전달해야함
- Set-Cookie로 쿠키에 담아서 전달
- 클라이언트는 쿠키저장소에 세션 ID저장
- 이제 모든 요청에 쿠키(세션ID 포함) 을 같이 전달하게됨

### 인증된 요청 처리

- 브라우저는 자동으로 저장된 쿠키도 함께 보냄
- 서버가 쿠키에서 세션ID를 꺼내서 확인
- 응답

### 로그인 상태 유지

- 브라우저를 닫지 않고 & 세션이 만료되지 않으면, 로그인 상태가 유지됨

### 로그아웃 처리

- 로그아웃 버튼 클릭 → 세션ID 삭제, 브라우저 쿠키도 만료되도록 응답

## JWT방식(회원관리)

`Header` + `Payload` + `Signature`

- **Header**: 토큰 타입(JWT), 서명 알고리즘 정보
- **Payload**: 사용자 정보, 토큰 만료 시간 등 클레임(Claim)
- **Signature**: (Header+Payload) 를 비밀키로 서명한 값(위조 방지)


<img width="800" height="611" alt="image" src="https://github.com/user-attachments/assets/9152a808-ec39-45d9-b297-9f6313762259" />


## 세션 방식과 JWT방식의 비교

| 구분 | 세션 방식(Stateful) | JWT 방식 (Stateless) |
| --- | --- | --- |
| **상태 저장 위치** | 서버(세션 저장소) | 클라이언트(토큰 자체) |
| **인증 데이터** | 세션 ID(쿠키에 저장) | JWT(쿠키·로컬스토리지 등) |
| **서버 확장성** | 낮음 (세션 공유 필요) | 높음 (서버 간 상태 공유 불필요) |
| **로그아웃 처리** | 서버 세션 삭제 → 즉시 무효 | 토큰 자체는 만료 전까지 유효(서버 차단 리스트 필요) |
| **보안** | 세션 ID 탈취 위험, 서버 쪽 관리 가능 | 토큰 탈취 시 만료까지 사용 가능 |
| **전송 데이터 크기** | 세션 ID만 전송(작음) | 사용자 정보까지 포함 → 크기 큼 |
| **유효 기간 관리** | 서버에서 제어 가능 | 발급 시 고정 (변경 불가, 재발급 필요) |

### 궁금한 부분
```
Q. 세션 방식은 왜 확장성이 낮은가?

A. 세션 방식은 상태를 서버에서 유지해야 해서 서버 수가 늘어날수록 세션 공유 인프라가 필요해지고 그것이 곧 확장성이 낮은것.
```

```
Q. JWT에서는 사용자가 맞는지 어떻게 DB를 거치지 않고 확인할까?

A. 서버는 토큰에서 Header와 Payload 부분만 가져와서 비밀키로 Signature 값을 새로 만든다.
   그러고 나서 **Signature(jwt 안에 있던애) vs Signature(다시 새로만든애)**  비교를 한다 
   일치하면 통과, 불일치 하면 변조감지
   공격자는 비밀키를 몰라서 Signature 를 변경할 수가 없다.
```
```
Q. JWT는 대체 어디에 저장해야 xss와 csrf를 방어할 수 있을까?

A. 좀더 조사해보고 있습니다…
참고 : https://cjw-awdsd.tistory.com/48
```
