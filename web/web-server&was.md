> **📅 업로드 날짜**  
> 2025-08-011
> 
> **🗂 분류**  
> web  
>
> **🔗 노션 링크**  
> [노션에서 보기](https://important-marquess-d42.notion.site/WAS-246a654e658a8033ba89f0be595e0ccb?source=copy_link)
> 
# 웹 서버와 WAS의 차이점

## 웹 서버

- 정적인 콘텐츠(HTML, CSS, JS, 이미지, 동영상 등)를 HTTP 프로토콜로 클라이언트에 제공하는 서버
- 요청이 들어오면 해당 파일을 읽어서 그대로 응답
- 리버스 프록시(Reverse Proxy) 역할 가능 → 요청을 다른 서버(WAS)로 전달
- 가볍고 효율적 → 대량의 정적 요청 처리에 최적화

## WAS

- 동적인 콘텐츠(사용자 요청마다 결과가 달라지는 페이지)를 생성하고 제공하는 서버
- 요청을 받아 비즈니스 로직 수행 → DB 연동 → 동적 응답 생성
- 동적 페이지 생성 속도는 정적 파일보다 느림 (로직·DB 연동 과정 포함)

## 웹의 요청과 응답의 전체 흐름

### 1. 사용자가 뭔가 ‘입력’한다

- HTTP/HTTPS 요청이 발생하겠지.

### 2. 브라우저 캐시 확인(네트워크 가기 전)

- 네트워크 요청 전, 브라우저 내부 저장소에서 동일 리소스가 있는지 먼저 확인
- 유효한 캐시 → 네트워크 없이 바로 응답 (`200 from cache`)
만료/검증 필요 → 서버에 조건부 요청 → 변경 없으면 `304 Not Modified`(기존 캐시 사용)
- 

※ 만료/검증 필요 : 캐싱된 값이 혹시 서버에서 변경됐나? 확인할때 조건부 요청을 함

### 3. DNS 조회

- 인터넷은 IP 주소(숫자) 로 통신하지만, 사람은 도메인 이름(글자) 을 기억한다.
- DNS는 도메인 → IP 주소로 바꿔주는 전화번호부 역할을 합니다
예) `www.example.com` ↦ `93.184.216.34`

- 캐시 있음(유효 TTL 내) → 바로 도메인 → IP 매핑 사용(네트워크 왕복 없이 매우 빠름)
- 캐시 없음/만료 → 재귀 DNS가 Root → TLD → 권한 네임서버 순서로 찾아와서 IP를 얻음

### 4. TLS 핸드셰이크

- HTTP/1.1·HTTP/2: `TCP 3-way handshake` → TLS 1.3 핸드셰이크 → 그다음에야 HTTP 요청 전송
- HTTP/3(QUIC): TCP 대신 QUIC(UDP) 사용. TLS 1.3이 QUIC 안에 포함되어 한 번에 끝남

**핸드 셰이크의 절차 (TLS 1.3, TCP 기반의 일반적인 경우)**

1. ClientHello ( 클라이언트가 먼저 시도)
    
    아래 제안 목록을 담아서 서버로 보냄
    
    - SNI : 접속하려는 호스트명 (www.example.com)
    - ALPN : 어떤 HTTP 계층 프로토콜 쓸지 (http/1.1 등)
    - 암호 옵션 : 데이터를 어떻게 암·복호화할지
    - key_share  : 어떤 키 교환 그룹/공개키로 할지
    
2. ServerHello ( 서버가 응답)
 ClientHello 의 제안을 선택/응답하는 단계
    - 암호 스위트 선택 : 클라이언트가 보낸 후보 중 선택 후 앞으로 모든 http를 암호
    - 키 교환 그룹 및 서버 공개키 전달 (key_share) : 자신의 임시 공개키를 보내서 **공유 비밀**을 계산할 수 있도록 함
    - 프로토콜 선택 : 이후 HTTP 통신은 이 프로토콜로 진행
    - 
    
3. Finished ↔ Finished
    
    같은 키를 갖고 있고, 대화 내용이 변조되지 않았음을 서로 증명하는 마지막 단계
    
    - 서로 Finished 메시지 전송 ( `verify_data`)
    - 받은 쪽이 자기 세션키로 똑같이 계산 → 값이 일치하면
        
        → 같은 키를 갖고 있고, 대화 내용이 변조되지 않았음을 확인
        
    

※공개키와 비밀키

- 클라이언트: 자기 개인키 × 서버 공개키 → 숫자 계산
- 서버: 자기 개인키 × 클라이언트 공개키 → 숫자 계산
    - 같은 그룹을 사용하면, 두 결과가 항상 똑같은 값이 나옴
    - →  이 값이 바로 **공유 비밀(shared secret)**
    - 공유비밀에 클라이언트 랜덤값 + 서버의 랜덤값을 넣어 최종적인 대칭키를 만들어낸다.
    - 대칭키가 만들어진 순간부터 , TLS는 그 키로 모든 HTTP 요청과 응답을 암호화/복호화하면서 안전하게 통신을 이어간다.

## 5. 웹 서버 처리( 요청 수신 & 라우팅)

- 예) Nginx, Apache

**브라우저 → 웹 서버 → WAS → DB/로직 처리 후 응답 → 웹 서버→ 브라우저**

- 정적 요청이면 바로 응답,
    - 예) HTML, CSS, JS, 이미지(JPG/PNG), 폰트, 동영상 파일 등
    - 이런 파일들은 서버 디스크나 캐시에 저장되어 있고, 웹 서버가 직접 읽어서 바로 응답 가능

- 동적 요청이면 WAS로 프록시
    - 예) 로그인한 사용자의 정보 페이지, 상품 목록, 검색 결과 등
    - 요청할 때마다 서버에서 계산·처리해서 만들어지는 응답
    - WAS가 로직 처리 후 응답을 웹 서버로 보내고, 웹 서버가 최종 전달

## WAS(Web Application Server)
<img width="758" height="261" alt="image (20)" src="https://github.com/user-attachments/assets/c678ad63-d9ca-4fc1-836e-f76794819115" />



- **웹 서버 + 애플리케이션 실행 환경**이 결합된 서버
- WAS는 웹서버 기능을 내장하고 있지만, 성능·부하 분산·보안·확장성 때문에 대규모 서비스에서는 **웹서버와 분리** 해서 운영하는 것이 일반적이다.

**WAS에서의 요청 처리 흐름** (Tomcat + Spring 예시)
 

<aside>
1️⃣

1. Nginx
    - 클라이언트 HTTP 요청 수신
    - 동적 요청으로 판단 → `proxy_pass`로 Tomcat에 전달
</aside>

<aside>
2️⃣

WAS(Tomcat) 커넥터

- 요청을 NIO Connector가 받아 **요청 큐**에 적재
- 워커 스레드 풀에서 스레드 하나를 할당

스레드풀 크기: 200

현재 요청 50개 → 스레드풀에서 50개 스레드가 처리

요청 210개 → 200개는 처리, 나머지 10개는 요청 큐에서 대기

</aside>

<aside>
3️⃣

1. 필터 체인(Filter Chain)
    - 공통 전처리 수행 (인증, 인가, CORS, 로깅, 캐시 헤더 설정 등)
    
</aside>

<aside>
4️⃣

1. **디스패처 서블릿(DispatcherServlet)** - Spring MVC
    - URL → 컨트롤러 메서드 매핑
    - 요청 데이터(@PathVariable, @RequestParam, @RequestBody) 바인딩
    - @Valid 유효성 검증
    
</aside>

<aside>
5️⃣

1. **비즈니스 로직(Service)**
    - 권한 체크, 규칙 처리, 외부 API 호출, 데이터 가공 등
</aside>

<aside>
6️⃣

1. **데이터 접근(Repository)**
    
    (HikariCP 커넥션 풀 → 트랜잭션 → SQL 실행 → 결과 매핑 → 커넥션 반납)
    
</aside>

<aside>
7️⃣

1. **응답 생성**
    - SSR: HTML 생성(Thymeleaf/JSP)
    - API: 객체 → JSON 변환
</aside>

<aside>
8️⃣

1. **응답 반환**
</aside>

## 응답 반환 경로

WAS → 웹 서버로 반환

- 웹 서버 마무리
- 필요한 경우 압축/헤더 추가/캐시 정책 적용 후 클라이언트로 전송.
